package main

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"runtime"
	"strings"

	docs "github.com/SolusiDataPintar/tickets/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/SolusiDataPintar/tickets/internal/account"
	"github.com/SolusiDataPintar/tickets/internal/auth"
	"github.com/SolusiDataPintar/tickets/internal/cache"
	"github.com/SolusiDataPintar/tickets/internal/env"
	"github.com/SolusiDataPintar/tickets/internal/http/app"
	"github.com/SolusiDataPintar/tickets/internal/price"
	"github.com/SolusiDataPintar/tickets/internal/vault"
	st "github.com/pkg/errors"
	echoSwagger "github.com/swaggo/echo-swagger" // echo-swagger middleware
)

const (
	appName = "chainsmart/nftticketplatform"
)

var (
	programLevel = new(slog.LevelVar)
)

//	@title			Chainsmart Ticket Platform API
//	@version		0.0.1

//	@BasePath	/api

//	@schemes	https http
//	@produce	application/json
//	@consumes	application/json

// @securityDefinitions.apikey	ApiKeyAuth
// @in							header
// @name						authorization
func main() {
	{
		logLevel, err := parseLogLevel(os.Getenv("LOG_LEVEL"))
		programLevel.Set(logLevel)

		opts := &slog.HandlerOptions{
			AddSource:   true,
			Level:       logLevel,
			ReplaceAttr: replaceAttr,
		}

		if programLevel.Level() >= slog.LevelInfo {
			l := slog.New(slog.NewJSONHandler(os.Stdout, opts)).With(
				slog.String("app", appName),
			)
			slog.SetDefault(l)
		} else {
			l := slog.New(slog.NewTextHandler(os.Stdout, opts)).With(
				slog.String("app", appName),
			)
			slog.SetDefault(l)
		}

		if err != nil {
			slog.Error("error parsing log level", slog.Any("err", err))
		}
	}

	cfg := env.LoadConfig()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	auth.NewService(
		auth.WithUrl(cfg.Auth.Url),
		auth.WithRealm(cfg.Auth.Realm),
		auth.WithClientId(cfg.Auth.ClientId),
		auth.WithClientSecret(cfg.Auth.ClientSecret),
		auth.WithAdminUsername(cfg.Auth.Admin.Username),
		auth.WithAdminPassword(cfg.Auth.Admin.Password),
	)

	cache.OpenConnection(cfg.Redis)
	defer cache.CloseConnection()

	vault.NewService().Open(cfg.Vault.Addr, cfg.Vault.Token, cfg.Vault.Timeout)

	price.NewService(price.WithUrl(cfg.PriceSource.Url))
	account.NewService(
		account.WithUrl(cfg.Auth.Url),
		account.WithRealm(cfg.Auth.Realm),
		account.WithAdminUsername(cfg.Auth.Admin.Username),
		account.WithAdminPassword(cfg.Auth.Admin.Password),
		account.WithActivationDuration(cfg.Auth.ActivationDuration),
		account.WithLinkUrlTemplate(cfg.Auth.LinkUrlTemplate),
	)

	docs.SwaggerInfo.Host = cfg.Host

	application := app.NewApp(programLevel.Level())
	application.Engine.GET("/swagger/*", echoSwagger.WrapHandler)
	application.Start(ctx, cfg.Host)
}

func parseLogLevel(level string) (slog.Level, error) {
	switch strings.ToUpper(level) {
	case "DEBUG":
		return slog.LevelDebug, nil
	case "INFO":
		return slog.LevelInfo, nil
	case "WARN":
		return slog.LevelWarn, nil
	case "ERROR":
		return slog.LevelError, nil
	default:
		return slog.LevelDebug, errors.New("unknown log level, revert to debug mode")
	}
}

func replaceAttr(groups []string, a slog.Attr) slog.Attr {
	switch a.Value.Kind() {
	// other cases

	case slog.KindAny:
		switch v := a.Value.Any().(type) {
		case error:
			a.Value = fmtErr(v)
		}
	}

	return a
}

// fmtErr returns a slog.GroupValue with keys "msg" and "trace". If the error
// does not implement interface { StackTrace() errors.StackTrace }, the "trace"
// key is omitted.
func fmtErr(err error) slog.Value {
	var groupValues []slog.Attr

	groupValues = append(groupValues, slog.String("msg", err.Error()))

	type StackTracer interface {
		StackTrace() st.StackTrace
	}

	// Find the trace to the location of the first errors.New,
	// errors.Wrap, or errors.WithStack call.
	var st StackTracer
	for err := err; err != nil; err = errors.Unwrap(err) {
		if x, ok := err.(StackTracer); ok {
			st = x
		}
	}

	if st != nil {
		groupValues = append(groupValues,
			slog.Any("trace", traceLines(st.StackTrace())),
		)
	}

	return slog.GroupValue(groupValues...)
}

func traceLines(frames st.StackTrace) []string {
	traceLines := make([]string, len(frames))

	// Iterate in reverse to skip uninteresting, consecutive runtime frames at
	// the bottom of the trace.
	var skipped int
	skipping := true
	for i := len(frames) - 1; i >= 0; i-- {
		// Adapted from errors.Frame.MarshalText(), but avoiding repeated
		// calls to FuncForPC and FileLine.
		pc := uintptr(frames[i]) - 1
		fn := runtime.FuncForPC(pc)
		if fn == nil {
			traceLines[i] = "unknown"
			skipping = false
			continue
		}

		name := fn.Name()

		if skipping && strings.HasPrefix(name, "runtime.") {
			skipped++
			continue
		} else {
			skipping = false
		}

		filename, lineNr := fn.FileLine(pc)

		traceLines[i] = fmt.Sprintf("%s %s:%d", name, filename, lineNr)
	}

	return traceLines[:len(traceLines)-skipped]
}
